import{connect}from'cloudflare:sockets';
const[d,e,U,C,P,S,B]=[new TextDecoder(),new TextEncoder(),[],{},new Map(),new Set(),new Uint8Array(8192)];
let W,T,O=0;
const init=n=>{if(C.done)return C;
C.I=n?.ID||'123456';
C.U=n?.UUID||'5aba5b77-48eb-4ae2-b60d-5bfee7ac169e';
C.P=n?.IP||['1.1.1.1'];
C.R=n?.PROXYIP||'sjc.o00o.ooo:443';
C.F=n?.启用反代功能??!0;
C.N=n?.NAT64??!1;
C.N2=n?.我的节点名字||'狂暴';
const u=C.U.replace(/-/g,'');
for(let i=0;i<32;i+=2)U[i>>1]=parseInt(u.substr(i,2),16);
return C.done=1,C};
const chk=a=>{for(let i=0;i<16;i++)if(a[i+1]!==U[i])return!1;return!0};
const to64=ip=>'2001:67c:2960:6464::'+ip.split('.').map(x=>(+x).toString(16).padStart(2,'0')).join('').match(/.{4}/g).join(':');
const tryConn=async(h,p,c,init)=>{const k=h+':'+p;if(P.has(k)){const cached=P.get(k);if(!S.has(k))return{...cached,initialData:init}}try{const s=await connect({hostname:h,port:p});await s.opened;const r={tcpSocket:s,initialData:init};P.set(k,r);return r}catch{S.add(k)}if(c.N&&/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(h))try{return await tryConn(to64(h),p,{...c,N:0},init)}catch{}if(c.F&&c.R){const[h2,p2]=c.R.split(':');return await tryConn(h2,+p2||p,{...c,F:0},init)}throw new Error('连接失败')};
const parseV=async(buf,c)=>{const a=new Uint8Array(buf),t=a[17],p=(a[18+t+1]<<8)|a[18+t+2];let o=18+t+4,h='';const at=a[o-1];if(at===1){h=a[o]+'.'+a[o+1]+'.'+a[o+2]+'.'+a[o+3];o+=4}else if(at===2){h=d.decode(a.subarray(o+1,o+1+a[o]));o+=a[o]+1}else if(at===3){h=Array.from({length:8},(_,i)=>((a[o+2*i]<<8)|a[o+2*i+1]).toString(16)).join(':');o+=16}return await tryConn(h,p,c,buf.slice(o))};
const tunnel=(ws,tcp,init)=>{const w=tcp.writable.getWriter(),r=tcp.readable.getReader();ws.send(new Uint8Array([0,0]));init&&w.write(init);let b=[],t,len=0;ws.addEventListener('message',({data})=>{const chunk=data instanceof ArrayBuffer?new Uint8Array(data):typeof data==='string'?e.encode(data):data;b.push(chunk);len+=chunk.length;t||(t=setTimeout(()=>{if(!len)return;if(b.length===1)w.write(b[0]);else{if(len<=8192){O=0;for(const x of b){B.set(x,O);O+=x.length}w.write(B.subarray(0,len))}else{const o=new Uint8Array(len);let pos=0;for(const x of b){o.set(x,pos);pos+=x.length}w.write(o)}}b=[];len=0;t=null},0))});(async()=>{try{for(;;){const{value,done}=await r.read();if(done)break;ws.send(value)}}catch{}finally{ws.close()}})();ws.addEventListener('close',()=>{try{r.releaseLock();w.releaseLock();tcp.close()}catch{}})};
const conf=(h,c)=>W||(W=c.P.concat([h+':443']).map(x=>{const[raw,name=c.N2]=x.split('#'),[addr,port=443]=raw.split(':');return`vless://${c.U}@${addr}:${port}?encryption=none&security=tls&type=ws&host=${h}&sni=${h}&path=%2F%3Fed%3D2560#${name}`}).join('\n'));
export default{async fetch(req,env){const c=init(env);if(req.headers.get('Upgrade')==='websocket'){try{const proto=req.headers.get('sec-websocket-protocol');if(!proto)return new Response('Missing protocol',{status:400});const data=Uint8Array.from(atob(proto.replace(/-/g,'+').replace(/_/g,'/')),c=>c.charCodeAt(0));if(!chk(data))return new Response('无效UUID',{status:403});const{tcpSocket,initialData}=await parseV(data.buffer,c),[client,server]=new WebSocketPair();server.accept();tunnel(server,tcpSocket,initialData);return new Response(null,{status:101,webSocket:client})}catch(e){return new Response('连接失败: '+e.message,{status:502})}}T||(T=req.headers.get('Host'));const p=new URL(req.url).pathname;return p===`/${c.I}`?new Response(`订阅地址: https://${T}/${c.I}/vless`):p===`/${c.I}/vless`?new Response(conf(T,c)):new Response('Hello Worker!')}}
