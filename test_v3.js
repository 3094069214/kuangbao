import{connect}from'cloudflare:sockets';
const d=new TextDecoder(),e=new TextEncoder();
const I='123456',UUID='5aba5b77-48eb-4ae2-b60d-5bfee7ac169e',P=['1.1.1.1','8.8.8.8','1.0.0.1'],R='sjc.o00o.ooo:443',F=1,N=0,N2='狂暴';
const U=Uint8Array.from(UUID.replace(/-/g,'').match(/.{2}/g).map(x=>parseInt(x,16)));
const chk=b=>{for(let i=0;i<U.length;i++)if(b[i]!==U[i])return 0;return 1};
const to64=ip=>'2001:67c:2960:6464::'+ip.split('.').map(x=>(+x).toString(16).padStart(2,'0')).join('').match(/.{4}/g).join(':');
const tryConn=async(h,p,c,init)=>{try{const s=await connect({hostname:h,port:p});return await s.opened,{tcpSocket:s,initialData:init}}catch{}if(N&&/^\d+\.\d+\.\d+\.\d+$/.test(h))try{return await tryConn(to64(h),p,{...c,N:0},init)}catch{}if(F&&R){const[h2,p2]=R.split(':');return await tryConn(h2,+p2||p,{...c,F:0},init)}throw new Error('连接失败')};
const parseV=async(buf,c)=>{const a=new Uint8Array(buf),t=a[17],p=(a[18+t+1]<<8)|a[18+t+2];let o=18+t+4,h='';switch(a[o-1]){case 1:h=`${a[o++]}.${a[o++]}.${a[o++]}.${a[o++]}`;break;case 2:{const l=a[o++];h=d.decode(a.subarray(o,o+l));o+=l;break}case 3:h=Array.from({length:8},(_, i)=>((a[o+2*i]<<8)|a[o+2*i+1]).toString(16)).join(':');o+=16}return await tryConn(h,p,c,buf.slice(o))};
const tunnel=(ws,tcp,init)=>{const w=tcp.writable.getWriter();ws.send(new Uint8Array([0,0]));init&&w.write(init);let b=[],t,closed=0;const cleanup=()=>{if(closed)return;closed=1,t&&clearTimeout(t),b=null;try{w.releaseLock(),tcp.close()}catch{}};ws.addEventListener('message',({data})=>{if(closed)return;const c=data instanceof ArrayBuffer?new Uint8Array(data):typeof data==='string'?e.encode(data):data;b.push(c),t||(t=setTimeout(()=>{if(closed)return;const total=b.length===1?b[0]:(()=>{const len=b.reduce((s,x)=>s+x.length,0),o=new Uint8Array(len);let pos=0;for(const x of b)o.set(x,pos),pos+=x.length;return o})();w.write(total).catch(cleanup),b.length=0,t=null},5))});tcp.readable.pipeTo(new WritableStream({write:d=>ws.send(d),close:cleanup,abort:cleanup})).catch(cleanup);ws.addEventListener('close',cleanup)};
const conf=h=>P.concat([`${h}:443`]).map(x=>{const[raw,name=N2]=x.split('#'),[addr,port=443]=raw.split(':');return`vless://${UUID}@${addr}:${port}?encryption=none&security=tls&type=ws&host=${h}&sni=${h}&path=%2F%3Fed%3D2560#${name}`}).join('\n');
export default{async fetch(req,env){const url=new URL(req.url),h=req.headers.get('Host');if(req.headers.get('Upgrade')!=='websocket'){const path=url.pathname;return path===`/${I}`?new Response(`订阅地址: https://${h}/${I}/vless`):path===`/${I}/vless`?new Response(conf(h)):new Response('Hello Worker!')}try{const proto=req.headers.get('sec-websocket-protocol'),data=Uint8Array.from(atob(proto.replace(/-/g,'+').replace(/_/g,'/')),c=>c.charCodeAt(0));if(!chk(data.subarray(1,17)))return new Response('无效UUID',{status:403});const{tcpSocket,initialData}=await parseV(data.buffer,{N,F}),[client,server]=new WebSocketPair();return server.accept(),tunnel(server,tcpSocket,initialData),new Response(null,{status:101,webSocket:client})}catch(e){return new Response('连接失败: '+e.message,{status:502})}}};
