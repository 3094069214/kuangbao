import{connect}from'cloudflare:sockets';
const[d,e,U,C]=[new TextDecoder(),new TextEncoder(),[],{}];
let W;
const g=(k,f,n)=>{const v=import.meta?.env?.[k]??n?.[k];return!v?f:typeof v!=='string'?v:(t=>t==='true'||t!=='false'&&(+t||t))(v.trim())};
const init=n=>{if(C.done)return C;for(const[k,[k2,d]]of[['I',['ID','123456']],['U',['UUID','5aba5b77-48eb-4ae2-b60d-5bfee7ac169e']],['P',['IP',['104.16.160.145']]],['R',['PROXYIP','sjc.o00o.ooo:443']],['F',['启用反代功能',!0]],['N',['NAT64',!1]],['N2',['我的节点名字','狂暴']]])C[k]=g(k2,d,n);U.push(...Uint8Array.from(C.U.replace(/-/g,'').match(/.{2}/g).map(x=>parseInt(x,16))));return C.done=1,C};
const chk=a=>{let i=16;while(i--)if(a[i+1]!==U[i])return!1;return!0};
const to64=ip=>'2001:67c:2960:6464::'+ip.split('.').map(x=>(+x).toString(16).padStart(2,'0')).join('').match(/.{4}/g).join(':');
const tryConn=async(h,p,c,init)=>{try{const s=await connect({hostname:h,port:p});await s.opened;return{tcpSocket:s,initialData:init}}catch{}if(c.N&&/^\d+\.\d+\.\d+\.\d+$/.test(h))try{return await tryConn(to64(h),p,{...c,N:0},init)}catch{}if(c.F&&c.R){const[h2,p2]=c.R.split(':');return await tryConn(h2,+p2||p,{...c,F:0},init)}throw 0};
const parseV=async(buf,c)=>{const a=new Uint8Array(buf),t=a[17],p=(a[18+t+1]<<8)|a[18+t+2];let o=18+t+4,h='';const at=a[o-1];if(at===1){h=`${a[o]}.${a[o+1]}.${a[o+2]}.${a[o+3]}`;o+=4}else if(at===2){const l=a[o];h=d.decode(a.subarray(o+1,o+1+l));o+=l+1}else if(at===3){h=Array.from({length:8},(_,i)=>((a[o+2*i]<<8)|a[o+2*i+1]).toString(16)).join(':');o+=16}return await tryConn(h,p,c,buf.slice(o))};
const tunnel=(ws,tcp,init)=>{const w=tcp.writable.getWriter();ws.send(new Uint8Array([0,0]));init&&w.write(init);let b=[],t;const flush=()=>{w.write(b.length===1?b[0]:(()=>{const len=b.reduce((s,x)=>s+x.length,0),o=new Uint8Array(len);let pos=0;for(const x of b)o.set(x,pos),pos+=x.length;return o})());b=[];t=null};ws.addEventListener('message',({data})=>{b.push(data instanceof ArrayBuffer?new Uint8Array(data):typeof data==='string'?e.encode(data):data);t||(t=setTimeout(flush,1))});const r=tcp.readable.getReader();(async()=>{try{for(;;){const{value,done}=await r.read();if(done)break;ws.send(value)}}catch{}finally{ws.close()}})();ws.addEventListener('close',()=>{try{r.releaseLock();w.releaseLock();tcp.close()}catch{}})};
const conf=(h,c)=>W||(W=c.P.concat([`${h}:443`]).map(x=>{const[raw,name=c.N2]=x.split('#'),[addr,port=443]=raw.split(':');return`vless://${c.U}@${addr}:${port}?encryption=none&security=tls&type=ws&host=${h}&sni=${h}&path=%2F%3Fed%3D2560#${name}`}).join('\n'));
export default{async fetch(req,env){const c=init(env);if(req.headers.get('Upgrade')==='websocket'){try{const proto=req.headers.get('sec-websocket-protocol');if(!proto)return new Response('No protocol',{status:400});const data=Uint8Array.from(atob(proto.replace(/-/g,'+').replace(/_/g,'/')),c=>c.charCodeAt(0));if(!chk(data))return new Response('Invalid UUID',{status:403});const{tcpSocket,initialData}=await parseV(data.buffer,c),[client,server]=new WebSocketPair();server.accept();tunnel(server,tcpSocket,initialData);return new Response(null,{status:101,webSocket:client})}catch{return new Response('Connection failed',{status:502})}}const p=new URL(req.url).pathname,h=req.headers.get('Host');return p===`/${c.I}`?new Response(`Subscribe: https://${h}/${c.I}/vless`):p===`/${c.I}/vless`?new Response(conf(h,c)):new Response('Hello Worker!')}}
